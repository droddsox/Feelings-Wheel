<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Feelings Wheel</title>
  <style>
    html, body, #container, #viewport {
      margin: 0;
      padding: 0;
      background: transparent !important;
      display: block;
      width: 100%;
      height: 100%;
      overflow: hidden;
      box-sizing: border-box;
      touch-action: none;
      overscroll-behavior: contain;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      position: fixed;
      inset: 0;
    }

    #container {
      width: 100%;
      max-width: 600px;
      height: auto;
      overflow: hidden;
      position: relative;
      background: transparent !important;
    }

    #viewport {
      width: 100%;
      height: 100%;
      position: relative;
      background: transparent !important;

      -webkit-mask-image: radial-gradient(farthest-side at 100% 50%, black 90%, transparent 100%),
                          linear-gradient(to bottom, transparent 0%, black 10%, black 90%, transparent 100%),
                          linear-gradient(to right, transparent 0%, black 10%);
      -webkit-mask-composite: destination-in;
      mask-composite: intersect;
      mask-image: radial-gradient(farthest-side at 100% 50%, black 90%, transparent 100%),
                  linear-gradient(to bottom, transparent 0%, black 10%, black 90%, transparent 100%),
                  linear-gradient(to right, transparent 0%, black 10%);
    }

    #draggable {
      position: absolute;
      transform-origin: center center;
      cursor: grab;
      border-radius: 50%;
      user-select: none;
      touch-action: none;
      background: transparent !important;
    }

    #draggable img {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      pointer-events: none;
      user-select: none;
      -webkit-user-drag: none;
      display: block;
      background: transparent !important;
    }
    /* nice visual feedback while dragging */
    #draggable.dragging { cursor: grabbing; }
  </style>
</head>
<body>
  <div id="container">
    <div id="viewport">
      <div id="draggable">
        <img src="https://raw.githubusercontent.com/droddsox/Feelings-Wheel/refs/heads/main/feelings_wheel.png" alt="Feelings Wheel" />
      </div>
    </div>
  </div>

  <script>
    (function () {
      const container = document.getElementById("container");
      const viewport = document.getElementById("viewport");
      const draggable = document.getElementById("draggable");

      function resize() {
        const vw = container.clientWidth;
        const vh = vw * (2 / 3);
        viewport.style.height = vh + "px";

        draggable.style.width = (vw * 2) + "px";
        draggable.style.height = (vw * 2) + "px";

        draggable.style.top = (-vh) + "px";
        draggable.style.left = (-vw) + "px";
      }

      window.addEventListener("resize", resize);
      resize();

      let active = false;
      let angle = 0;           // current rendered base angle (degrees)
      let rotation = 0;       // during drag: delta from start
      let startAngle = 0;
      const R2D = 180 / Math.PI;
      let center = { x: 0, y: 0 };

      let lastTime = 0;
      let lastAngle = 0;
      let angularVelocity = 0;
      let spinning = false;

      // Smooth scroll rotation variables
      let targetAngle = 0;
      const SCROLL_SPEED = 0.03; // smaller = slower per scroll tick
      const EASE = 0.08;         // easing factor for smoothness (smaller = smoother/slower)

      function getCenter(el) {
        const rect = el.getBoundingClientRect();
        return {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2,
        };
      }

      function startRotate(clientX, clientY) {
        if (spinning) {
          spinning = false; // stop current spin if user starts dragging
        }
        center = getCenter(draggable);
        const dx = clientX - center.x;
        const dy = clientY - center.y;
        startAngle = R2D * Math.atan2(dy, dx);
        lastAngle = startAngle;
        lastTime = performance.now();
        active = true;
        draggable.classList.add('dragging');
      }

      function moveRotate(clientX, clientY) {
        if (!active) return;
        const dx = clientX - center.x;
        const dy = clientY - center.y;
        const currentAngle = R2D * Math.atan2(dy, dx);
        rotation = currentAngle - startAngle;

        const now = performance.now();
        const deltaTime = now - lastTime;
        const deltaAngle = currentAngle - lastAngle;

        // degrees per second
        angularVelocity = deltaAngle / (deltaTime / 1000 || 1);

        lastAngle = currentAngle;
        lastTime = now;

        // immediate visual update (drag should feel responsive)
        const rendered = angle + rotation;
        draggable.style.transform = `rotate(${rendered}deg)`;

        // keep the scroll/target system in sync so easing continues smoothly when released
        targetAngle = rendered;
      }

      function endRotate() {
        if (!active) return;
        angle += rotation;
        rotation = 0;
        targetAngle = angle; // sync scroll + drag
        active = false;
        draggable.classList.remove('dragging');
        spinWithInertia();
      }

      function spinWithInertia() {
        // If angularVelocity is near zero, don't start spin
        if (Math.abs(angularVelocity) < 0.5) {
          angularVelocity = 0;
          spinning = false;
          return;
        }

        const friction = 0.985;
        spinning = true;

        function step() {
          if (!spinning) return;

          angularVelocity *= friction;
          // angularVelocity is degrees/second, step at ~60fps
          angle += angularVelocity * (1 / 60);

          // keep targetAngle synced so scroll easing doesn't fight the spin
          targetAngle = angle;

          draggable.style.transform = `rotate(${angle}deg)`;

          // stop condition
          if (Math.abs(angularVelocity) < 0.01) {
            spinning = false;
            angularVelocity = 0;
            return;
          }
          requestAnimationFrame(step);
        }

        requestAnimationFrame(step);
      }

      // Mouse events
      draggable.addEventListener("mousedown", (e) => {
        e.preventDefault();
        startRotate(e.clientX, e.clientY);
      });

      window.addEventListener("mousemove", (e) => {
        if (active) {
          e.preventDefault();
          moveRotate(e.clientX, e.clientY);
        }
      });

      window.addEventListener("mouseup", () => {
        endRotate();
      });

      // Touch events
      draggable.addEventListener("touchstart", (e) => {
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          startRotate(touch.clientX, touch.clientY);
          e.preventDefault();
        }
      }, { passive: false });

      draggable.addEventListener("touchmove", (e) => {
        if (e.touches.length === 1) {
          const touch = e.touches[0];
          moveRotate(touch.clientX, touch.clientY);
          e.preventDefault();
        }
      }, { passive: false });

      window.addEventListener("touchend", (e) => {
        if (active) {
          endRotate();
          e.preventDefault();
        }
      }, { passive: false });

      // Scroll-to-rotate (smooth easing)
      window.addEventListener("wheel", (e) => {
        e.preventDefault();
        // stop any inertia spinning so wheel has control
        spinning = false;
        angularVelocity = 0;

        // slower, smoother scroll per user's request
        targetAngle += e.deltaY * SCROLL_SPEED;
      }, { passive: false });

      // Animation loop for smooth scroll rotation
      function animateScrollRotation() {
        // Only ease when not actively dragging and not handled by inertia spin
        if (!active && !spinning) {
          // ease angle toward targetAngle
          angle += (targetAngle - angle) * EASE;
          // small threshold snap to avoid perpetual tiny differences
          if (Math.abs(targetAngle - angle) < 0.001) angle = targetAngle;
          draggable.style.transform = `rotate(${angle}deg)`;
        } else {
          // while active or spinning, keep targetAngle synced to current 'angle' so future easing is smooth
          // (moveRotate and spinWithInertia already update targetAngle when appropriate)
        }
        requestAnimationFrame(animateScrollRotation);
      }
      animateScrollRotation();

    })();
  </script>
</body>
</html>
